ch02.Elixirビルド時に何が起こっているか
=======================================

makeコマンドでElixirをビルドする時、何が起こっているかをいくつかのフェーズに分けて説明していきます。

全体の流れ
----------

makeを行うとMakefileの内容でElixirがビルドされます。ビルドは大きく以下のフェーズに分けられます。

1. rebarを使ってErlangで記述されたElixirコンパイラをコンパイル
2. Elixirコンパイラを使ってElixirで記述されたElixirカーネルをコンパイル
3. Elixirコンパイラを使ってElixirで記述された関連ツール(eex,mix,ex_unit,logger,iex)をコンパイル

Elixirコンパイラ
----------------

makeコマンドを実行するとまずElixirコンパイラがコンパイルされます。 この時、以下の処理が実行されます。

```bash
cd /path/to/elixir/repo/lib/elixir && ../../rebar compile
```

コンパイルの順は以下となります。

1. elixir/src/elixir.app.srcをelixir/lib/elixir/srcにコピーする
2. elixir/lib/elixir/src以下のErlangコードをコンパイルしてelixir/lib/elixir/ebin以下に実行ファイル(.beam,.app)として配置する

src以下のErlangソースコードは4種類あります。

### elixir.app.src

elixir.app.srcはelixir.appのテンプレートファイルです。これを元にelixir.appとしてebin以下に配置されます。

### elixir.hrl

elixir.hrlはErlangのヘッダファイルです。Elixirコンパイラモジュールに関する定義等が記述されています。

### elixir_xxx.erl

elixir_xxx.erlはErlangのソースコードです。 コンパイルされるとebin以下にelixir_xxx.beamとして配置されます。

### elixir_parser.yrl

elixir_parser.yrlはyeccパーサージェネレーターファイル、yeccはErlangのLALR(1)パーサージェネレータです。

パーサージェネレータとは何ぞやという方は、(yeccではなくyacc,raccなんですが) RHGの[速習yacc](http://i.loveruby.net/ja/rhg/book/yacc.html)、[Rubyを256倍使うための本 無道編](http://www.amazon.co.jp/Rubyを256倍使うための本-無道編-青木-峰郎/dp/4756137091)がお勧めです。

yeccの詳しい使い方は[Erlangの公式ドキュメント](http://erlang.org/doc/man/yecc.html)を参照して下さい。 まとまった日本語の情報は残念ながら見つけられませんでした。 yeccについては後章で掘り下げて説明します。

elixir_parser.yrlファイルをコンパイルすると、src以下にelixir_parser.erlが生成され、 さらにebin以下にelixir_parser.beamが生成されます。

Elixirカーネル
--------------

Elixirコンパイラのコンパイルが終わると、 次にElixirカーネルがコンパイルされます。 Elixirカーネルのコンパイルは以下のフェーズに分けられます。

1. ElixirコンパイラでElixirで記述されたコアモジュールをコンパイル
2. bin/elixircでElixirで記述されたカーネルモジュールをコンパイル
3. bin/elixircでElixirで記述された標準ライブラリをコンパイル
4. bin/elixircでElixirで記述されたUnicodeモジュールをコンパイル
5. elixir.appを削除して、rebarでErlangで記述されたElixirコンパイラを再コンパイル

### コアモジュール

コアモジュールはElixirコンパイラでコンパイルされます。 この時、以下の処理が実行されます。

```bash
cd /path/to/elixir/repo/lib/elixir
erl -I lib/elixir/include \
    -noshell -pa lib/elixir/ebin \
    -s elixir_compiler core -s erlang halt
```

`erl`はErlangランタイムを呼び出すコマンドです。 以下のオプションを付けて起動したElixirコンパイラがコアモジュールをコンパイルします。

#### -noshell

-noshellを付けるとErlangの対話シェルを起動せずに実行します。 ただし標準入力を閉じはしないので、 処理が完了したら明示的にコマンドを終了される必要があります。

#### -pa lib/elixir/ebin

-paは後ろに続くディレクトリをコードパス(の先頭)に追加します。 このオプションによって、lib/elixir/ebin以下のモジュールがプログラム実行時にロードされます。

#### -s elixir_compiler core

-s Mod Func を指定する事で、erl実行時に Modモジュールの関数Funcを実行する事ができます。 このオプションによって、elixir_compilerモジュールのcore関数が実行されます。

#### -s erlang halt

-noshellで起動しているので、明示的に終了するよう erlangモジュールのhalt関数を実行して終了させます。

つまり、コアモジュールのコンパイルとは、 elixir_compilerモジュールの、core関数を実行する事です。 core関数がElixirコンパイルのエントリポイントと言えるでしょう。

後章で、core関数によるコンパイル処理について詳しく説明します。

### bin/elixirc

コアモジュールのコンパイルが完了すると、次にカーネルモジュールがコンパイルされます。 この時、以下が実行されます。

```bash
cd /path/to/elixir/repo
./bin/elixirc --verbose --ignore-module-conflict "lib/elixir/lib/kernel.ex" -o lib/elixir/ebin
```

カーネルモジュールのコンパイルの前に、bin/elixircについて見ていきます。

elixircの実体はシェルスクリプトです。 最終的にelixircは以下のコマンドに展開されます。

```bash
cd /path/to/elixir/repo
exec erl -pa lib/elixir/ebin \
         -elixir ansi_enabled true \
         -noshell -s elixir start_cli \
         -extra +elixirc --verbose --ignore-module-conflict \
         "lib/elixir/lib/kernel.ex" -o lib/elixir/ebin
```

#### -flagname flagval1 flagval2 ...

erl起動時のフラグ(先頭に`-`が付いた値)は、Erlangプログラムの中で、`init:get_arguments().`で取得できます。

```
~ $ erl -myflag flagval1 flagval2
Erlang/OTP 17 [erts-6.0] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V6.0  (abort with ^G)
1> init:get_arguments().
[{root,["/usr/local/Cellar/erlang/17.0/lib/erlang"]},
 {progname,["erl"]},
 {home,["/Users/ohr486"]},
 {myflag,["flagval1","flagval2"]}]
2> q().
ok
3> ~ $
```

`-I lib/elixir/include -elixir ansi_enabled true`

の場合は、

```erlang
[{'I',["lib/elixir/include"]},
 {elixir,["ansi_enabled","true"]}]
```

がErlangプログラムに渡されます。

#### -extra arg1 arg2 ...

-extraオプションを付けてerlを起動すると、後ろに続く引数をErlangプログラムの中で、`init:get_plain_arguments().`で取得する事ができます。

```
~ $ erl -extra arg1 arg2 arg3
Erlang/OTP 17 [erts-6.0] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V6.0  (abort with ^G)
1> init:get_plain_arguments().
["arg1","arg2","arg3"]
2> q().
ok
3> ~ $
```

`-extra +elixirc --verbose --ignore-module-conflict "lib/elixir/lib/kernel.ex" -o lib/elixir/ebin`

の場合は、

```erlang
["+elixirc","--verbose","--ignore-module-conflict",
 "lib/elixir/lib/kernel.ex","-o","lib/elixir/ebin"]
```

がErlangプログラムに渡ります。

つまりelixircの実行とは、erlコマンドでelixirモジュールのstart_cli関数を、 (各種オプション引数を付けて) 実行する事なのです。

### カーネルモジュール

それではカーネルモジュールのコンパイルについて見ていきます。

前説で説明した通り、カーネルモジュールのコンパイル時の処理を再掲します。

```bash
cd /path/to/elixir/repo
exec erl -pa lib/elixir/ebin \
         -elixir ansi_enabled true \
         -noshell -s elixir start_cli \
         -extra +elixirc --verbose --ignore-module-conflict \
         "lib/elixir/lib/kernel.ex" -o lib/elixir/ebin
```

つまり、カーネルモジュールのコンパイルとは、 elixirモジュールの、start_cliを以下の引数付きで実行する事です。

```erlang
{elixir,["ansi_enabled","true"]}
```

```erlang
["+elixirc","--verbose","--ignore-module-conflict",
 "lib/elixir/lib/kernel.ex","-o","lib/elixir/ebin"]
```

後章で、start_cli関数によるコンパイル処理について詳しく説明します。

### 標準ライブラリ

次に標準ライブラリのコンパイルですが、以下の様な処理が走ります。 これはカーネルモジュールのコンパイルと引数`lib/elixir/lib/**/*.ex`以外は同じです。

```bash
cd /path/to/elixir/repo
./bin/elixirc --verbose --ignore-module-conflict "lib/elixir/lib/**/*.ex" -o lib/elixir/ebin
```

elixirモジュールの、start_cliを以下の引数付きで実行。

```erlang
{elixir,["ansi_enabled","true"]}
```

```erlang
["+elixirc","--verbose","--ignore-module-conflict",
 "lib/elixir/lib/kernel.ex","-o","lib/elixir/ebin"]
```

こちらも後章で、start_cli関数によるコンパイル処理について詳しく説明します。

### Unicodeモジュール

次にUnicodeモジュールのコンパイルです。 これも標準ライブラリ同様に引数`lib/elixir/lib/**/*.ex`以外は同じです。

```bash
cd /path/to/elixir/repo
./bin/elixirc --verbose --ignore-module-conflict "unicode/unicode.ex" -o lib/elixir/ebin
```

elixirモジュールの、start_cliを以下の引数付きで実行。

```erlang
{elixir,["ansi_enabled","true"]}
```

```erlang
["+elixirc","--verbose","--ignore-module-conflict",
 "lib/elixir/unicode/unicode.ex","-o","lib/elixir/ebin"]
```

こちらも後章で、start_cli関数によるコンパイル処理について詳しく説明します。

### Elixirコンパイラの再コンパイル

最後に`elixir.app`を削除し、rebarでelixirを再コンパイルします。

```bash
rm -rf /path/to/elixir/repo/lib/elixir/ebin/elixir.app
cd /path/to/elixir/repo/lib/elixir && ../../rebar compile
```

もう既にコンパイル済なのに、何故最後に再コンパイルするのでしょうか？
それは`elixir.app`の構成モジュール指定`modules`の為です。

初回コンパイル時の`elixir.app`は以下の様になります。

```erlang
{application,elixir,
             [{description,"elixir"},
              {vsn,"0.15.2-dev"},
              {modules,[elixir,...(src以下のErlangモジュール)]},
              {registered,[elixir_code_server]},
              {applications,[kernel,stdlib,
                             crypto,compiler,syntax_tools]},
              {mod,{elixir,[]}},
              {env,[{uri,#{}},{ansi_enabled,false}]}]}.
```

modulesには`src`以下のErlangソースファイルからコンパイルされたモジュールが指定されます。

そして次が`elixir.app`を削除して再コンパイルした結果できた`elixir.app`です。

```erlang
{application,elixir,
             [{description,"elixir"},
              {vsn,"0.15.2-dev"},
              {modules,['Elixir.Access',...(lib以下のElixirモジュール),
                        'Elixir.String.Unicode(Unicodeモジュール)',
                        elixir,...(src以下のErlangモジュール)]},
              {registered,[elixir_code_server]},
              {applications,[kernel,stdlib,
                             crypto,compiler,syntax_tools]},
              {mod,{elixir,[]}},
              {env,[{uri,#{}},{ansi_enabled,false}]}]}.
```

ご覧の通り、modulesには`src`以下のモジュールだけでなく、
`lib`以下のElixirのソースファイルからコンパイルされたモジュールと、
`unicode/unicode.ex`からコンパイルされた`Elixir.String.Unicode`も指定されています。

つまり、再コンパイルの理由は、elixirアプリケーションの構成モジュールに、
Elixirのカーネルモジュール、Unicodeモジュールも指定する為です。

関連ツール(`eex`,`mix`,`ex_unit`,`logger`,`iex`)
------------------------------------------------

TODO:Elixirを使って関連ツールをコンパイルする旨を書く
